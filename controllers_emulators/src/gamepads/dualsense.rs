use crate::{gamepad::{Gamepad, GamepadStatus}, device::Device};
use crate::message::{InDeviceDataMessage, OutDeviceDataMessage};

use uhid_virt::{Bus, CreateParams, UHIDDevice, OutputEvent};

use std::time::Duration;

#[derive(Clone)]
pub struct DualSenseSettings {
    pub bluetooth: bool,
    pub edge: bool,
    pub mac_addr: [u8; 6],
}

impl Default for DualSenseSettings {
    fn default() -> Self {
        Self {
            bluetooth: true,
            edge: false,
            mac_addr: [ 0x74u8, 0xe7u8, 0xd6u8, 0x3au8, 0x47u8, 0xe8u8 ],
        }
    }
}

pub struct DualSense {
    settings: DualSenseSettings,
    status: GamepadStatus,
    device: UHIDDevice<std::fs::File>,
}

impl Drop for DualSense {
    fn drop(&mut self) {

    }
}

impl Device for DualSense {
    fn write_timing(&self) -> Option<Duration> {
        Some(Duration::from_millis(4))
    }

    fn write_report(&self) {
        
    }

    fn read_requests(&mut self) {
        match self.device.read() {
            Ok(out_ev) => {
                match out_ev {
                    uhid_virt::OutputEvent::Start { dev_flags } => {},
                    uhid_virt::OutputEvent::Open => {},
                    uhid_virt::OutputEvent::Close => {},
                    uhid_virt::OutputEvent::Stop => {},
                    uhid_virt::OutputEvent::SetReport { id, report_number, report_type, data } => {
                        println!("SetReport id: {}, report_number: {}", id, report_number);
                    },
                    uhid_virt::OutputEvent::GetReport { id, report_number, report_type } => {
                        println!("GetReport id: {}, report_number: {}", id, report_number);

                        if report_number == 0x09 {
                            // pairing info
                            println!("DualSense pairing info requested");
                            let _ = self.device.write_get_report_reply(id, 0, vec![
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00,
                            ]);
                        } else if report_number == 0x20 {
                            // report info
                        }
                    },
                    _ => {}
                }
            },
            Err(stream_err) => {

            }
        }
    }

    fn handle_message(&mut self, msg: &InDeviceDataMessage) {
        match msg {
            InDeviceDataMessage::Gamepad(gamepad_msg) => crate::gamepad::process_gamepad_message(self, &gamepad_msg),
            _ => println!("Message type not implemented")
        }
    }

    fn generate_message(&mut self) -> Option<OutDeviceDataMessage> {
        println!("Unimplemented feature!");
        //todo!()
        None
    }
}

impl Gamepad for DualSense {
    fn get_status(&self) -> GamepadStatus {
        self.status
    }

    fn set_status(&mut self, stat: &GamepadStatus) {
        self.status = stat.clone();
    }
}

impl DualSense {
    pub fn new(settings: DualSenseSettings) -> Result<Self, Box<dyn std::error::Error>> {
        match UHIDDevice::create(CreateParams {
            name: String::from("Sony Corp. DualSense Edge wireless controller (PS5)"),
            phys: String::from("00:01:02:03:03:04"),
            uniq: String::from("00:01:02:03:03:04"),
            bus: Bus::USB,
            vendor: 0x054c,
            product: 0x0df2,
            version: 0,
            country: 0,
            // This is a device which emits the usage code as a whole, rather than as bits
            rd_data: [
                0x05, 0x01, 0x09, 0x05, 0xA1, 0x01, 0x85, 0x01, 0x09, 0x30, 0x09, 0x31, 0x09, 0x32, 0x09, 0x35,
                0x09, 0x33, 0x09, 0x34, 0x15, 0x00, 0x26, 0xFF, 0x00, 0x75, 0x08, 0x95, 0x06, 0x81, 0x02, 0x06,
                0x00, 0xFF, 0x09, 0x20, 0x95, 0x01, 0x81, 0x02, 0x05, 0x01, 0x09, 0x39, 0x15, 0x00, 0x25, 0x07,
                0x35, 0x00, 0x46, 0x3B, 0x01, 0x65, 0x14, 0x75, 0x04, 0x95, 0x01, 0x81, 0x42, 0x65, 0x00, 0x05,
                0x09, 0x19, 0x01, 0x29, 0x0F, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x0F, 0x81, 0x02, 0x06,
                0x00, 0xFF, 0x09, 0x21, 0x95, 0x0D, 0x81, 0x02, 0x06, 0x00, 0xFF, 0x09, 0x22, 0x15, 0x00, 0x26,
                0xFF, 0x00, 0x75, 0x08, 0x95, 0x34, 0x81, 0x02, 0x85, 0x02, 0x09, 0x23, 0x95, 0x3F, 0x91, 0x02,
                0x85, 0x05, 0x09, 0x33, 0x95, 0x28, 0xB1, 0x02, 0x85, 0x08, 0x09, 0x34, 0x95, 0x2F, 0xB1, 0x02,
                0x85, 0x09, 0x09, 0x24, 0x95, 0x13, 0xB1, 0x02, 0x85, 0x0A, 0x09, 0x25, 0x95, 0x1A, 0xB1, 0x02,
                0x85, 0x20, 0x09, 0x26, 0x95, 0x3F, 0xB1, 0x02, 0x85, 0x21, 0x09, 0x27, 0x95, 0x04, 0xB1, 0x02,
                0x85, 0x22, 0x09, 0x40, 0x95, 0x3F, 0xB1, 0x02, 0x85, 0x80, 0x09, 0x28, 0x95, 0x3F, 0xB1, 0x02,
                0x85, 0x81, 0x09, 0x29, 0x95, 0x3F, 0xB1, 0x02, 0x85, 0x82, 0x09, 0x2A, 0x95, 0x09, 0xB1, 0x02,
                0x85, 0x83, 0x09, 0x2B, 0x95, 0x3F, 0xB1, 0x02, 0x85, 0x84, 0x09, 0x2C, 0x95, 0x3F, 0xB1, 0x02,
                0x85, 0x85, 0x09, 0x2D, 0x95, 0x02, 0xB1, 0x02, 0x85, 0xA0, 0x09, 0x2E, 0x95, 0x01, 0xB1, 0x02,
                0x85, 0xE0, 0x09, 0x2F, 0x95, 0x3F, 0xB1, 0x02, 0x85, 0xF0, 0x09, 0x30, 0x95, 0x3F, 0xB1, 0x02,
                0x85, 0xF1, 0x09, 0x31, 0x95, 0x3F, 0xB1, 0x02, 0x85, 0xF2, 0x09, 0x32, 0x95, 0x34, 0xB1, 0x02,
                0x85, 0xF4, 0x09, 0x35, 0x95, 0x3F, 0xB1, 0x02, 0x85, 0xF5, 0x09, 0x36, 0x95, 0x03, 0xB1, 0x02,
                0x85, 0x60, 0x09, 0x41, 0x95, 0x3F, 0xB1, 0x02, 0x85, 0x61, 0x09, 0x42, 0xB1, 0x02, 0x85, 0x62,
                0x09, 0x43, 0xB1, 0x02, 0x85, 0x63, 0x09, 0x44, 0xB1, 0x02, 0x85, 0x64, 0x09, 0x45, 0xB1, 0x02,
                0x85, 0x65, 0x09, 0x46, 0xB1, 0x02, 0x85, 0x68, 0x09, 0x47, 0xB1, 0x02, 0x85, 0x70, 0x09, 0x48,
                0xB1, 0x02, 0x85, 0x71, 0x09, 0x49, 0xB1, 0x02, 0x85, 0x72, 0x09, 0x4A, 0xB1, 0x02, 0x85, 0x73,
                0x09, 0x4B, 0xB1, 0x02, 0x85, 0x74, 0x09, 0x4C, 0xB1, 0x02, 0x85, 0x75, 0x09, 0x4D, 0xB1, 0x02,
                0x85, 0x76, 0x09, 0x4E, 0xB1, 0x02, 0x85, 0x77, 0x09, 0x4F, 0xB1, 0x02, 0x85, 0x78, 0x09, 0x50,
                0xB1, 0x02, 0x85, 0x79, 0x09, 0x51, 0xB1, 0x02, 0x85, 0x7A, 0x09, 0x52, 0xB1, 0x02, 0x85, 0x7B,
                0x09, 0x53, 0xB1, 0x02, 0xC0
            ]
            .to_vec(),
        }) {
            Ok(uhid_dev) => {
                Ok(
                    Self {
                        settings: settings,
                        status: GamepadStatus::default(),
                        device: uhid_dev
                    }
                )
            },
            Err(err) => Err(Box::new(err))
        }
    }
}

/*
impl Default for DualSense {
    fn default() -> Self {
        DualSense::new(DualSenseSettings::default()).unwrap
    }
}
*/
